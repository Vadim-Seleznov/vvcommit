import subprocess
import sys
import os
import shutil
import urllib.request

# CONSTANTS WITH CONSOLE COLORS
RED = "\033[31m"
GREEN = "\033[32m"
GREY = "\033[90m"
RESET = "\033[0m"

# OTHER CONSTANTS
BRANCH_TYPES = {
        "f": "feature",
        "h": "hotfix",
        "e": "empty",
        "b": "bugfix",
        }


# UPDATE FUNCTION
# With this function you can get newest version of script from github with only 1 command
# also it has --no-backup flag if you dont want to save backup with older version
def update(flag: str) -> None:
    url = "https://raw.githubusercontent.com/Vadim-Seleznov/vvcommit/main/vvcommit.py"
    script_path = os.path.realpath(sys.argv[0])
    backup_path = script_path + ".bak"

    print("Starting update...")

    try:
        response = urllib.request.urlopen(url)
        data = response.read().decode("utf-8")

        if flag == "backup":
            shutil.copy2(script_path, backup_path)
            print(f"{GREY}Backup created at: {backup_path}{RESET}")

        with open(script_path, "w", encoding="utf-8") as f:
            f.write(data)

        print(f"{GREEN}Update completed successfully!{RESET}")
    except Exception as e:
        print(f"{RED}ERROR Update failed {RESET}: {e}")
        if os.path.exists(backup_path):
            shutil.copy2(backup_path, script_path)
            print(f"{GREEN}Restored backup version.{RESET}")
        sys.exit(1)

    sys.exit(0)

# HELP FUNCTION TO PRINT TUTORIAL FOR REQUESTS IN TERMINAL
def help() -> None:
    print(f"{GREY}--------------------VV HELP----------{RESET}")
    print(f"{RED}Request options:{RESET}")
    print(f"{GREEN}curr - git commit and push into current branch{RESET}")
    print(f"{GREEN}comm - git commit into current branch without pushing{RESET}")
    print(f"{GREEN}cbranch - git commit and push into specific branch{RESET}")
    print(f"{GREEN}pull - git pull or git pull origin \"branch-name\" if you provide an argument (python ./vvcommit.py pull (optional branch name)){RESET}")
    print(f"{GREEN}ignore \"elements\"- adding files into .gitignore {RESET}")
    print(f"{GREEN}ignore -\"elements\" --restore - to restore files from .gitignore{RESET}")
    print(f"{GREEN}branch-create - to create and switch into new branch{RESET}")
    print(f"{GREEN}branch-end - merge stuff from specific branch and (optional) delete it{RESET}")
    print(f"{GREEN}init - to init github repo in current directory from scratch with github-login and repo-name{RESET}")
    print(f"{GREEN}push-ex - pushing stuff into existing github repo using github-login and repo-name{RESET}")
    print(f"{GREEN}update - for getting newest version of tool from github! (--no-backup for not creating .bak file){RESET}")
    print(f"{GREEN}If you use branch request you should give extra argument with branch name{RESET}")
    print(f"{GREEN}EXAMPLE:{RESET} python ./vvcommit.py branch \"main\" \"small fix\"")
    sys.exit(0)

# THIS FUNCTION IS FOR PRINTING USAGE OF ANY REQUEST
def usage(message: str) -> None:
    print(f'{RED}ERROR{RESET}: {GREY}usage: python ./vvcommit.py {message}{RESET}')
    sys.exit(1)

# ADD AND COMMIT + PUSH STUFF INTO CURRENT BRANCH WITH SIMPLE COMMAND
def commit_curr(commit_message: str) -> None:
    subprocess.run(["git", "add", "."])

    result = subprocess.run(["git", "commit", "-m", commit_message])
    if result.returncode != 0:
        print(f"{RED}Commit failed!{RESET}")
        sys.exit(1)
    subprocess.run(["git", "push"])

    print(f'{GREEN}Successful commit{RESET}: {commit_message}')

    sys.exit(0)

# ADD + COMMIT + PUSH STUFF INTO SPECIFIC BRANCH
def commit_branch(branch: str, commit_message) -> None:
    subprocess.run(["git", "add", "."])

    result = subprocess.run(["git", "commit", "-m", commit_message])
    if result.returncode != 0:
        print(f"{RED}Commit failed!{RESET}")
        sys.exit(1)

    subprocess.run(["git", "push", "origin", branch])

    print(f'{GREEN}Successful commit: {commit_message} into branch: {branch}{RESET}')

    sys.exit(0)

# ADD + COMMIT INTO CURRENT BRANCH WITHOUT PUSH
def commit(commit_message: str) -> None:
    subprocess.run(["git", "add", "."])

    result = subprocess.run(["git", "commit", "-m", commit_message])
    if result.returncode != 0:
        print(f"{RED}Commit failed!{RESET}")
        sys.exit(1)

    print(f'{GREEN}Successful commit: {commit_message}{RESET}')

    sys.exit(0)

# PULL STUFF FROM CURRENT OR SPECIFIC BRANCH
def pull(branch: str = "none") -> None:
    if branch == "none":
        subprocess.run(["git", "pull"])
    else:
        subprocess.run(["git", "pull", "origin", branch])

    sys.exit(0)

# INIT GIT REPO ABSOLUTELY FROM SCRATCH
# to use it just go to github website create new repo
# then use init command with yours username + repo-name
def init(login: str, repo: str) -> None:
    subprocess.run(["git", "init", "."])
    subprocess.run(["git", "add", "."])
    result = subprocess.run(["git", "commit", "-m", "Initial commit"])
    if result.returncode != 0:
        print(f"{RED}Commit failed!{RESET}")
        sys.exit(1)
    subprocess.run(["git", "branch", "-M", "main"])
    subprocess.run(["git", "remote", "add", "origin", f'https://github.com/{login}/{repo}.git'])
    subprocess.run(["git", "push", "-u", "origin", "main"])

    sys.exit(0)

# PUSH STUFF INTO EXISTING GITHUB REPO (also using username and repo-name)
def push_ex(login: str, repo: str) -> None:
    subprocess.run(["git", "remote", "add", "origin", f'https://github.com/{login}/{repo}.git'])
    subprocess.run(["git", "branch", "-M", "main"])
    subprocess.run(["git", "push", "-u", "origin", "main"])

    sys,exit(0)

# ADD PROGRAM AND ALL OF IT FILES INTO .gitignore AND MAKE THEM NOT VISABLE
def ignore(paths: str) -> None:
    print(f"{GREY}Ignoring myself :< {RESET}")

    try:
        path = './.gitignore'
        elements: list = paths.split(" ")
        with open(path, "a") as f:
            for el in elements:
                f.write(f'{el}\n')
        
        subprocess.run(["git", "rm", "--cached", elements])

        print(f"{GREEN}Added to {elements} into .gitignore succefully!{RESET}")

        print(f"{GREEN}Now just commit + push...{RESET}")
        subprocess.run(["git", "commit", "-m", f"Ignored: {elements}"])
        subprocess.run(["git", "push"])
        sys.exit(0)
    except Exception as e:
        print(f"{RED}ERROR:{RESET} {e}")
        sys.exit(1)

# BACKUP FUNCTION FOR ignore()
def restore_ignore(pahts: str) -> None:
    try:
        print(f"{GREY}Restore script started successfully{RESET}")
        path = "./.gitignore"
        elements: list = pahts.split(" ")
        with open(path, "r") as f:
            print(f"{GREY}Reading from .gitignore{RESET}")
            lines = f.readlines()
            with open(path, "w") as new_file:
                for line in lines:
                    if not line in elements:
                        new_file.write(line)

        print(f"{GREEN}Successfully removed from .gitignore: {elements}!{RESET}")
        print(f"{GREY}Trying to add files...{RESET}")


        subprocess.run(["git", "add", "-f", elements])
        
        subprocess.run(["git", "add", ".gitignore"])

        print(f"{GREEN}Successful added! Now just commit + push...{RESET}")
        subprocess.run(["git", "commit", "-m", f"Restored: {elements}"])
        subprocess.run(["git", "push"])
        sys.exit(0)
    except Exception as e:
        print(f"{RED}ERROR:{RESET} {e}")
        sys.exit(1)

# FUNCTION FOR CREATING A NEW BRANCH AND SWITCHING INTO
def branch_create(name: str, branch_type: str, user_option: str = "") -> None:
    if branch_type == "c":
        if not user_option:
            usage("branch-create c option-name branch-name")
        option = user_option
    else:
        if branch_type not in BRANCH_TYPES:
            print(f'{RED}ERROR:{RESET} there is no such branch type option: {branch_type}')
            usage("branch-create (f, h, b or c) name")

        option = BRANCH_TYPES[branch_type]
    if option != "empty":
        full_name = f"{option}/{name}"
    else:
        full_name = name

    subprocess.run(["git", "switch", "main"])
    subprocess.run(["git", "pull"])
    subprocess.run(["git", "switch", "-c", full_name])

    print(f'{GREEN}SUCCESSFULLY CREATED AND SWITCHED INTO: {full_name}{RESET}')
    sys.exit(0)

# FUNCTION TO MERGE ALL STUFF FROM SPECIFIC BRANCH INTO MAIN AND (OPTIONAL) DELETE THIS BRANCH
def branch_end(name: str, delete: bool = False, remote: bool = False)-> None:
    print(f'{GREY}Trying to find branch: {name}{RESET}')
    result = subprocess.run(["git", "branch"], capture_output=True, text=True)
    branches = result.stdout.splitlines()

    branches = [b.strip().lstrip("* ").strip() for b in branches]

    target_branch = next((b for b in branches if b.endswith(name)), None)

    if not target_branch:
        print(f'{RED}ERROR:{RESET} there is no such branch!: {name}')
        sys.exit(1)

    print(f"{GREEN}BRANCH: {target_branch} was found{RESET}")
    subprocess.run(["git", "add", "."])

    subprocess.run(["git", "commit", "-m", f'end up with branch: {name}'])

    subprocess.run(["git", "switch", "main"])
    subprocess.run(["git", "pull"])

    subprocess.run(["git", "merge", target_branch])

    if delete:
        subprocess.run(["git", "branch", "-d", target_branch])
    
        if remote:
            subprocess.run(["git", "push", "origin", "--delete", target_branch])

    subprocess.run(["git", "push"])

    sys.exit(0)


# MAIN FUNCTION
def main() -> None:
    print(f"{GREEN}Welcome from vvcommit!{RESET}")
    
    if len(sys.argv) < 2:
        usage("request")

    request = sys.argv[1]

    if request == "com":
        if len(sys.argv) != 3:
            usage("com commit-message")
        commit_message = sys.argv[2]
        commit(commit_message)

    if request == "branch-end":
        if len(sys.argv) < 3:
            usage("branch-end (delete optional) (remote optional) name (without prefix)")

        if "delete" in sys.argv and "remote" in sys.argv:
            if len(sys.argv) != 5:
                usage("branch-end delete remote name (without prefix)")

            name = sys.argv[4]
            branch_end(name, True, True)
        elif "delete" in sys.argv:
            if len(sys.argv) != 4:
                usage("branch-end delete name (without prefix)")

            name = sys.argv[3]
            branch_end(name, True, False)
        else:
            if len(sys.argv) != 3:
                usage("branch-end name (without prefix)")

            name = sys.argv[2]
            branch_end(name, False, False)

    if request == "branch-create":
        if len(sys.argv) < 4:
            usage("branch-create (f, b, h or c) name")

        if sys.argv[2] == "c":
            if len(sys.argv) != 5:
                usage("branch-create c option-name branch-name")

            user_option = sys.argv[3]
            branch_name = sys.argv[4]
            branch_create(branch_name, "c", user_option)
        else:
            branch_option = sys.argv[2]
            branch_name = sys.argv[3]
            branch_create(branch_name, branch_option)

    if request == "init":
        if len(sys.argv) != 4:
            usage("init github-login repo-name")

        user_login = sys.argv[2]
        repo = sys.argv[3]
        init(user_login, repo)

    if request == "push-ex":
        if len(sys.argv) != 4:
            usage("push-ex github-login repo-name")

        user_login = sys.argv[2]
        repo = sys.argv[3]
        push_ex(user_login, repo)

    if request == "ignore":
        if len(sys.arv) == 3:
            elements = sys.argv[2]
            ignore(elements)
        elif len(sys.argv) == 4:
            elements = sys.argv[2]
            if sys.argv[3] == "--restore":
                restore_ignore(elements)
            else:
                help()
        else:
            print(f'Wrong command: {sys.argv}')
            help()

    if request == "help":
        help()

    if request == "update":
        if len(sys.argv) >= 3:
            if sys.argv[2] == "--no-backup":
                update("no-backup")
            else:
                print(f'There is no such flag: {sys.argv[2]}')
                help()

        update("with-backup")
    if request == "pull":
        pull()
        
    if request == "cbranch":
        if len(sys.argv) < 4:
            usage("cbranch branch-name commit-message")
        
        branch = sys.argv[2]
        commit_message = sys.argv[3]
        commit_branch(branch, commit_message)

    if len(sys.argv) < 3: usage("request commit-message")

    commit_message = sys.argv[2]

    if request == "pull":
        branch = sys.argv[2]
        pull(branch)
    
    if request == "curr":
        commit_curr(commit_message)

    print(f"{RED}ERROR:{RESET} no such request!")
    help()

if __name__ == "__main__":
    main()

